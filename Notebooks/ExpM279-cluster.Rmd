---
title: "ExpM279 notebook"
author: "Manuel Rivera"
date: "2025-03-04"
output: 
  html_document:
    toc: true           # Enable Table of Contents
    theme: sandstone
    toc_float: true
    collapsed: false
    smooth_scroll: true
---

## Generate parameters 

### Attach Packages
```{r, eval = FLASE, warning = FALSE}
library(dplyr) 
library(tidyr)
require(tidyverse, lib.loc = "/mnt/atgc-d3/sur/modules/pkgs/tidyverse_mrc")
require(lubridate, lib.loc = "/mnt/atgc-d3/sur/modules/pkgs/tidyverse_mrc")
require(svglite, lib.loc = "/mnt/atgc-d3/sur/modules/pkgs/tidyverse_mrc")

```

### Generate grid and save it

Create a grid of parameters.

- Species counts (`n_species`)
- Normal distribution mean (`Norm_mu`)
- Normal distribution standard deviation (`sigma`)
- No interaction probability (`p_noint`)
- Seed for initial population (`x0_seed`)
- Seed for growth rates population  (`mu_seed`)
- Seed for interactions  (`A_seed`)
```{r, eval=FALSE}
param.generate.fun <- function() {
  n_species <- rep(c(10, 30, 100), times = 10)
  
  grid <- expand_grid(
    n_species = n_species,
    Norm_mu = 0,
    sigma = seq(from = 1, to = 20, by = 0.5),
    p_noint = seq(from = 0, to = 1, by = 0.05)
  )
  
  grid %>%
    mutate(
      id = ids::random_id(nrow(grid), bytes = 4),
      x0_seed = sample(1:1e6, nrow(grid), replace = FALSE),
      mu_seed = sample(1:1e6, nrow(grid), replace = FALSE),
      A_seed = sample(1:1e6, nrow(grid), replace = FALSE),
      diagonal = -0.5
    )
}

params.to.sim <- param.generate.fun()
```



### Verify parameters

```{r}
# For cluster environment, use the appropriate path: 
source("/mnt/atgc-d3/sur/users/mrivera/glv-research/GIT-gLV/Method2-normal/generate-gLV-normal.R")
print(regenerate_Dnormal)
```

## Load parameters table

```{r}
# For cluster environment, use the appropriate path: 
params_table <- data.table::fread("/mnt/atgc-d3/sur/users/mrivera/glv-research/Data/ExpM279-D06M03.tsv")
head(params_table)
```


```{r}
# Calculate the observed null and negative probability.
tmp <-  lapply(1:nrow(params_table), function(i) {
  
  # cat("Starting simulation ", i,"...\n")
  p <- regenerate_Dnormal(params_table[i,]) # Regenerate the parameters
  
  # Get non-diagonal elements in one step
  non_diag_elements <- p$M[row(p$M) != col(p$M)]
  
  # Efficiently compute proportions using mean (avoids explicit sums)
  p_neg_obs <- mean(non_diag_elements < 0)
  p_noint_obs <- mean(non_diag_elements == 0)
  inters_vals <- non_diag_elements
  
  # Return named vector
  tibble(id = p$id,
         p_neg_obs = p_neg_obs, 
         p_noint_obs = p_noint_obs,
         values = list(inters_vals)
  )
})

df.result <- bind_rows(tmp)

# For faster rendering we will be saving the environment

```


```{r}
tictoc::tic("Section 1: Divide data into chunks")
num_cores <- parallel::detectCores() - 1  # Use one less than the total number of cores
cat("The number of cores that will be used are: ", num_cores, "\n")

split_table <- function(df, n_chunks) {
  split(df, cut(seq_len(nrow(df)), breaks = n_chunks, labels = FALSE))
}

chunks <- split_table(params_table, num_cores)
toc() # For section 1
```


```{r}

# Regenerate parameters for each of the simulations
parallel.params <- function(index) {
  
  
  p <- regenerate_Dnormal(index) # Generate parameters
  
  # Get non-diagonal elements in one step and compute statistics
  non_diag_elements <- p$M[row(p$M) != col(p$M)]
  
  # Efficient computation of the proportions
  p_neg_obs <- mean(non_diag_elements < 0)
  p_noint_obs <- mean(non_diag_elements == 0)
  inters_vals <- non_diag_elements
  
  # Return a tibble with the results
  return(tibble(
    id = p$id,
    p_neg_obs = p_neg_obs, 
    p_noint_obs = p_noint_obs,
    values = list(inters_vals))
  )
  
}
```


```{r}
results <- parallel::mclapply(1:num_cores, function(core_id) {
  
  message("Starting worker ", core_id, "....\n")
  
  core_chunk <- chunks[[core_id]]  # rows assigned to this core
  
  df <- lapply(1:nrow(core_chunk), function(i) {
    parallel.params(core_chunk[i, ])
  })
  
  message("Ending worker ", core_id, "....\n")
  
  return(df)
  
}, mc.cores = num_cores)


# Convert list to a tibble or data frame
result_df <- bind_rows(results)

```


```{r}
glimpse(result_df)
```


```{r}

error.df <- params_table %>%
  select(id, n_species, Norm_mu, sigma, p_noint) %>% # select columns of interest
  full_join(result_df, by = join_by(id)) %>%  # Negative and Null oserved probabilities 
  group_by(Norm_mu, sigma, p_noint, n_species) %>%
  summarize(values = list(unlist(values)), 
            Sims_done = n(),  # Count total simulations done with the combination of parameters
            er_noint = p_noint_obs - p_noint
  )


head(error.df)
```


## Create graphs

Errors graphs:
```{r}
suppressPackageStartupMessages(library(ggplot2))

p1 <- error.df %>%
  ggplot(aes(x = p_noint, y = er_noint)) +
  geom_point() +
  geom_hline(yintercept = 0, col = "red") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 90))

p1
ggsave("/mnt/atgc-d3/sur/users/mrivera/glv-research/GIT-gLV/Notebooks/ExpM279-errors.svg", width = 6, height = 4)
```


```{r}
#' Blackbox theme
#' 
#' ggplot2 theme that places a black margin on every
#' panel
#'
#' @param border.size Thickness of the margin.
#'
#' @return A \code{theme gg} object.
#' @export
#' @author Sur Herrera Paredes
theme_blackbox <- function(border.size = 3){
  theme(axis.text = element_text(color="black"),
        axis.title = element_text(face="bold"),
        panel.background = element_rect(color = "black",
                                        size = border.size,
                                        fill = NA),
        panel.grid = element_blank())
}
```

```{r, eval=FALSE}
p2 <- error.df %>%
  filter(sigma %% 1 == 0) %>% # Filters rows where the value is an integer (no decimals)
  unnest(cols = values) %>% 
  ggplot(aes(x = factor(sigma), y = values)) +
  # facet_wrap(~ n_species) +  # Facet by 'n_species'
  geom_boxplot() +
  theme_blackbox()


p2


x <- error.df %>%
  filter(sigma %% 1 == 0, # Filters rows where the value is an integer (no decimals)
         n_species == 10) %>% 
  unnest(cols = values) %>%
  ggplot(aes(x = factor(sigma), y = values)) +
  geom_boxplot() +
  theme_blackbox()

# Use the svg() function for saving
svg("/mnt/atgc-d3/sur/users/mrivera/glv-research/GIT-gLV/Notebooks/ExpM279-test.svg", width = 6, height = 4)
print(x)  # Display the plot
dev.off()  # Close the device

ggsave("/mnt/atgc-d3/sur/users/mrivera/glv-research/GIT-gLV/Notebooks/ExpM279-test.svg", plot = x, device = "svg")
```


```{r, eval = FALSE}


ggsave("/mnt/atgc-d3/sur/users/mrivera/glv-research/GIT-gLV/Notebooks/ExpM279-p2.svg", width = 6, height = 4)

```